%MEAM517
%Greg Campbell & Spencer Folk
%Rework of Morbidi 2016 Paper

%This function provides the h(z) constraints based on the dynamics of the
%system.

%Note - 11/8: the following two functions have been unupdated from
%Homework 5. They must be updated to include the dynamics of our system.

%Note - 11/12: the first function appears to be fine as-is. Second function
%will require more work.

function [h,dH] = dynamics_constraints(z, N, nx, nu, dt)
%DYNAMICS_CONSTRAINTS(z) compiles the dynamics constraints generated by
%dynamics_constraint_with_derivative.
%   @param z: decision variable (column) vector containing the x_i and u_i
%   @param N: number of sample points; scalar
%   @param nx: dimension of state vector, x; scalar
%   @param nu: dimension of input vector, u; scalar
%   @param dt: \Delta t, the inter-sample interval duration; scalar

%   @output h: compiled h_i from dynamics_constraint_with_derivative;
%   (N-1)*nx by 1 vector
%   @output dH_i: compiled dH_i from dynamics_constraint_with_derivative;
%   (N-1)*nx by nz matrix

    h = zeros((N-1)*nx, 1);
    dH = zeros((N-1)*nx, N*(nx + nu));

    for i=1:(N-1)

        % TODO: call dynamics_constraint_with_derivative ith sample
        %Manage indices and solve for x/u i and ip1
        [x_i_inds, u_i_inds] = sample_indices(i, nx, nu);
        [x_ip1_inds, u_ip1_inds] = sample_indices(i+1, nx, nu);
        x_i = z(x_i_inds);
        u_i = z(u_i_inds);
        x_ip1 = z(x_ip1_inds);
        u_ip1 = z(u_ip1_inds);
        %Call dynamics_constraint_with_derivative
        [h_i,dH_i] = dynamics_constraint_with_derivative(x_i, u_i, x_ip1, u_ip1, dt);

        % TODO fit h_i and dH_i into h and dH, respectively.
        h(x_i_inds) = h_i;
        dH(x_i_inds,[x_i_inds,u_i_inds,x_ip1_inds,u_ip1_inds]) = dH_i;

    end

end

function [h_i,dH_i] = dynamics_constraint_with_derivative(x_i, u_i, x_ip1, u_ip1, dt)
%DYNAMICS_CONSTRAINT_WITH_DERIVATIVE(x_i, u_i, x_ip1, u_ip1, dt) returns
%and computes the gradient of the vector constraint asssociated with
%dynamics_constraint(x_i, u_i, x_ip1, u_ip1, dt).
%Originally created by Matt Halm for MEAM517.
%
%   @param x_i: the state at the start of the interval; nx by 1 vector
%   @param u_i: the input at the start of the interval; nu by 1 vector
%   @param x_ip1: the state at the end of the interval; nx by 1 vector
%   @param u_ip1: the input at the end of the interval; nu by 1 vector
%   @param dt: \Delta t, the duration of the interval; scalar
%
%   @output h_i: constraint value from dynamics_constraint; nx by 1 vector
%   @output dH_i: jacobian of h_i w.r.t. [x_i; u_i; x_ip1; u_ip1]; nx by
%   (2nx + 2nu) matrix

    h_i = evaluate_dynamics_constraint(x_i, u_i, x_ip1, u_ip1, dt);
    if nargout > 1
      % use numerical derivatives to compute dH
      % dH = [dh/dx0 dh/du0 dh/dx1 dh/du1]
      % where the partial derivatives are written (dh/dx0)_ij = dh_i/dx0_j
      delta = 1e-8;
      dH_i = zeros(numel(x_i), 2*(numel(x_i)+numel(u_i)));
      for j=1:numel(x_i)
          dx = zeros(numel(x_i),1);
          dx(j) = delta;
          dHx_i_j = evaluate_dynamics_constraint(x_i + dx, u_i, x_ip1, u_ip1, dt) - h_i;
          dHx_ip1_j = evaluate_dynamics_constraint(x_i, u_i, x_ip1 + dx, u_ip1, dt) - h_i;
          dH_i(:,j) = dHx_i_j/delta;
          dH_i(:,j + numel(x_i) + numel(u_i)) = dHx_ip1_j/delta;
      end

      for j=1:numel(u_i)
          du = zeros(numel(u_i),1);
          du(j) = delta;
          dHu_i_j = evaluate_dynamics_constraint(x_i, u_i + du, x_ip1, u_ip1, dt) - h_i;
          dHu_ip1_j = evaluate_dynamics_constraint(x_i, u_i, x_ip1, u_ip1 + du, dt) - h_i;
          dH_i(:,j + numel(x_i)) = dHu_i_j/delta;
          dH_i(:,j + numel(x_i) + numel(u_i) + numel(x_ip1)) = dHu_ip1_j/delta;
      end
    end
end


function h_i = evaluate_dynamics_constraint(x_i, u_i, x_ip1, u_ip1, dt)
%EVALUATE_DYNAMICS_CONSTRAINT(x_i, u_i, x_ip1, u_ip1, dt) computes the
%   vector contstraint h_i(x_i, u_i, x_ip1, u_ip1) = 0 from Problem 2(c)
%
%   @param x_i: the state at the start of the interval; nx by 1 vector
%   @param u_i: the input at the start of the interval; nu by 1 vector
%   @param x_ip1: the state at the end of the interval; nx by 1 vector
%   @param u_ip1: the input at the end of the interval; nu by 1 vector
%   @param dt: \Delta t, the duration of the interval; scalar
%
%   @output h_i: quantity derived in Problem 2(c); nx by 1 vector
nx = numel(x_i);

h_i = zeros(nx,1);
f_i = f(x_i,u_i);
f_ip1 = f(x_ip1,u_ip1);

% TODO: Calculate constraint value

%Impliment equations to perform multiple-shooting - use spline from HW5

%Old equation - potentially still useful.
Si = 0.5*(x_i+x_ip1)-dt/8*(f_ip1-f_i);
Sdi = 3/(2*dt)*(x_ip1-x_i)-1/4*(f_ip1+f_i);
ri = 0.5*(u_i+u_ip1);

h_i = Sdi - f(Si,ri);

% %Attempt 1
% s0 = x_i;
% s1 = f_i;
% s2 = 3*(x_ip1-x_i)/dt^2-(2*f_i+f_ip1)/dt;
% s3 = (f_ip1+f_i)/dt^2 + 2*(x_i-x_ip1)/dt^3;
% 
% Si0 = s0;
% Sif = s0 + s1*dt + s2*dt^2 + s3*dt^3;
% Sdi0 = s1;
% Sdif = s1 + s2*dt + s3*dt^2;
% 
% ri0 = u_i;
% rif = u_ip1;
% 
% h_i(1) = Sdi0 - f(Si0,ri0);
% h_i(2) = Sdif - f(Sif,rif);

%new effort - 11/12 (failed)
% h_i = x_i + dt/2*(f_i+f_ip1)-x_ip1;

end